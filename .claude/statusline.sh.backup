#!/bin/bash
# Generated by cc-statusline (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: 2025-08-23T05:29:46.567Z
# Theme: detailed | Colors: true | Features: directory, model, context, usage, session, tokens, burnrate

LOG_FILE="${HOME}/.claude/statusline.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# ---- logging ----
{
  echo "[$TIMESTAMP] Status line triggered with input:"
  (echo "$input" | jq . 2>/dev/null) || echo "$input"
  echo "---"
} >> "$LOG_FILE" 2>/dev/null

input=$(cat)

# ---- color helpers (force colors for Claude Code) ----
use_color=1
[ -n "$NO_COLOR" ] && use_color=0

C() { if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$1"; fi; }
RST() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- modern sleek colors ----
dir_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;117m'; fi; }    # sky blue
model_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;147m'; fi; }  # light purple  
version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;180m'; fi; } # soft yellow
cc_version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;249m'; fi; } # light gray
style_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; } # gray
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- time helpers ----
to_epoch() {
  ts="$1"
  if command -v gdate >/dev/null 2>&1; then gdate -d "$ts" +%s 2>/dev/null && return; fi
  date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${ts/Z/+0000}" +%s 2>/dev/null && return
  python3 - "$ts" <<'PY' 2>/dev/null
import sys, datetime
s=sys.argv[1].replace('Z','+00:00')
print(int(datetime.datetime.fromisoformat(s).timestamp()))
PY
}

fmt_time_hm() {
  epoch="$1"
  if date -r 0 +%s >/dev/null 2>&1; then date -r "$epoch" +"%H:%M"; else date -d "@$epoch" +"%H:%M"; fi
}

# ---- Enhanced Progress Bar Functions ----
# Performance-optimized progress bar generator (<10ms execution)
# Compatible with cc-statusline visual patterns and terminal color codes

# Core progress bar generator - creates ASCII bars like [========--]
progress_bar() {
  local pct="${1:-0}" width="${2:-10}" char_fill="${3:-=}" char_empty="${4:--}"
  
  # Input validation (using only bash built-ins for performance)
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0
  ((pct < 0)) && pct=0
  ((pct > 100)) && pct=100
  [[ "$width" =~ ^[0-9]+$ ]] || width=10
  ((width < 1)) && width=1
  ((width > 50)) && width=50
  
  # Fast integer math for bar calculation
  local filled=$((pct * width / 100))
  local empty=$((width - filled))
  
  # Optimized string generation using printf only
  printf '%*s' "$filled" '' | tr ' ' "$char_fill"
  printf '%*s' "$empty" '' | tr ' ' "$char_empty"
}

# Enhanced progress bar with color coding based on percentage
progress_bar_colored() {
  local pct="${1:-0}" width="${2:-10}" show_pct="${3:-true}"
  local bar_content color_start color_end
  
  # Input validation using bash arithmetic only
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0
  ((pct < 0)) && pct=0
  ((pct > 100)) && pct=100
  
  # Performance-optimized color selection using bash conditionals
  if ((pct >= 80)); then
    color_start='\033[38;5;203m'  # coral red (high usage)
  elif ((pct >= 60)); then
    color_start='\033[38;5;215m'  # peach (medium usage)  
  elif ((pct >= 40)); then
    color_start='\033[38;5;228m'  # light yellow (moderate usage)
  else
    color_start='\033[38;5;158m'  # mint green (low usage)
  fi
  color_end='\033[0m'
  
  # Generate bar content with enhanced characters
  bar_content="[$(progress_bar "$pct" "$width" "█" "░")]"
  
  # Output with optional percentage display
  if [ "$use_color" -eq 1 ]; then
    if [ "$show_pct" = "true" ]; then
      printf '%b%s%b %b%d%%%b' "$color_start" "$bar_content" "$color_end" "$color_start" "$pct" "$color_end"
    else
      printf '%b%s%b' "$color_start" "$bar_content" "$color_end"
    fi
  else
    if [ "$show_pct" = "true" ]; then
      printf '%s %d%%' "$bar_content" "$pct"
    else
      printf '%s' "$bar_content"
    fi
  fi
}

# Specialized session usage progress bar (follows cc-statusline patterns)
session_usage_progress() {
  local pct="${1:-0}" width="${2:-12}" label="${3:-Session}"
  local remaining_pct bar_color bar_content
  
  # Input validation
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0
  ((pct < 0)) && pct=0
  ((pct > 100)) && pct=100
  
  # Calculate remaining percentage for color logic (matches existing pattern)
  remaining_pct=$((100 - pct))
  
  # Color selection matching existing session_color() logic
  if ((remaining_pct <= 10)); then
    bar_color='\033[38;5;210m'  # light pink (critical)
  elif ((remaining_pct <= 25)); then
    bar_color='\033[38;5;228m'  # light yellow (warning)
  else
    bar_color='\033[38;5;194m'  # light green (healthy)
  fi
  
  # Generate bar using original function style for compatibility
  bar_content="[$(progress_bar "$pct" "$width" "=" "-")]"
  
  # Output in cc-statusline format
  if [ "$use_color" -eq 1 ]; then
    printf '%b%s: %d%% %s%b' "$bar_color" "$label" "$pct" "$bar_content" '\033[0m'
  else
    printf '%s: %d%% %s' "$label" "$pct" "$bar_content"
  fi
}

# Multi-metric progress display (for complex usage scenarios)
multi_progress_display() {
  local cpu_pct="${1:-0}" mem_pct="${2:-0}" disk_pct="${3:-0}" width="${4:-8}"
  
  printf 'CPU: %s  MEM: %s  DSK: %s' \
    "$(progress_bar_colored "$cpu_pct" "$width" false)" \
    "$(progress_bar_colored "$mem_pct" "$width" false)" \
    "$(progress_bar_colored "$disk_pct" "$width" false)"
}

# Compact progress indicator for single values (ultra-fast)
compact_progress() {
  local pct="${1:-0}"
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0
  ((pct < 0)) && pct=0
  ((pct > 100)) && pct=100
  
  local chars="▁▂▃▄▅▆▇█"
  local idx=$((pct * 7 / 100))
  printf '%s' "${chars:$idx:1}"
}

# ---- Progress Bar Usage Examples and Testing ----
# (Remove this section in production - for development/testing only)
test_progress_functions() {
  echo "=== Enhanced Progress Bar Functions Demo ==="
  echo
  
  echo "1. Basic progress_bar() function:"
  for pct in 0 25 50 75 100; do
    echo "  ${pct}%: $(progress_bar "$pct" 20)"
  done
  echo
  
  echo "2. Colored progress_bar_colored() with percentages:"
  for pct in 15 35 55 75 95; do
    echo -n "  ${pct}%: "
    progress_bar_colored "$pct" 15 true
    echo
  done
  echo
  
  echo "3. Session usage progress (cc-statusline style):"
  for pct in 10 40 70 85 95; do
    echo -n "  "
    session_usage_progress "$pct" 12 "Session"
    echo
  done
  echo
  
  echo "4. Multi-metric display:"
  echo -n "  "
  multi_progress_display 25 60 80 10
  echo
  echo
  
  echo "5. Compact progress indicators:"
  echo -n "  Progress levels: "
  for pct in 0 12 25 37 50 62 75 87 100; do
    echo -n "$(compact_progress $pct) "
  done
  echo
  echo
  
  echo "6. Edge cases and validation:"
  echo "  Invalid input (-10): $(progress_bar -10 10)"
  echo "  Invalid input (150): $(progress_bar 150 10)"
  echo "  Invalid input (abc): $(progress_bar abc 10)"
  echo "  Zero width: $(progress_bar 50 0)"
  echo
}

# ---- basics ----
if command -v jq >/dev/null 2>&1; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
else
  current_dir="unknown"
  model_name="Claude"; model_version=""
  session_id=""
  cc_version=""
  output_style=""
fi

# ---- context window calculation ----
context_pct=""
context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[1;37m'; fi; }  # default white

# Determine max context based on model
get_max_context() {
  local model_name="$1"
  case "$model_name" in
    *"Opus 4"*|*"opus 4"*|*"Opus"*|*"opus"*)
      echo "200000"  # 200K for all Opus versions
      ;;
    *"Sonnet 4"*|*"sonnet 4"*|*"Sonnet 3.5"*|*"sonnet 3.5"*|*"Sonnet"*|*"sonnet"*)
      echo "200000"  # 200K for Sonnet 3.5+ and 4.x
      ;;
    *"Haiku 3.5"*|*"haiku 3.5"*|*"Haiku 4"*|*"haiku 4"*|*"Haiku"*|*"haiku"*)
      echo "200000"  # 200K for modern Haiku
      ;;
    *"Claude 3 Haiku"*|*"claude 3 haiku"*)
      echo "100000"  # 100K for original Claude 3 Haiku
      ;;
    *)
      echo "200000"  # Default to 200K
      ;;
  esac
}

if [ -n "$session_id" ] && command -v jq >/dev/null 2>&1; then
  MAX_CONTEXT=$(get_max_context "$model_name")
  
  # Convert current dir to session file path
  project_dir=$(echo "$current_dir" | sed "s|~|$HOME|g" | sed 's|/|-|g' | sed 's|^-||')
  session_file="$HOME/.claude/projects/-${project_dir}/${session_id}.jsonl"
  
  if [ -f "$session_file" ]; then
    # Get the latest input token count from the session file
    latest_tokens=$(tail -20 "$session_file" | jq -r 'select(.message.usage) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' 2>/dev/null | tail -1)
    
    if [ -n "$latest_tokens" ] && [ "$latest_tokens" -gt 0 ]; then
      context_used_pct=$(( latest_tokens * 100 / MAX_CONTEXT ))
      context_remaining_pct=$(( 100 - context_used_pct ))
      
      # Set color based on remaining percentage
      if [ "$context_remaining_pct" -le 20 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;203m'; fi; }  # coral red
      elif [ "$context_remaining_pct" -le 40 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;215m'; fi; }  # peach
      else
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }  # mint green
      fi
      
      context_pct="${context_remaining_pct}%"
    fi
  fi
fi

# ---- usage colors ----
usage_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;189m'; fi; }  # lavender
cost_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;222m'; fi; }   # light gold
burn_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;220m'; fi; }   # bright gold
session_color() { 
  rem_pct=$(( 100 - session_pct ))
  if   (( rem_pct <= 10 )); then SCLR='38;5;210'  # light pink
  elif (( rem_pct <= 25 )); then SCLR='38;5;228'  # light yellow  
  else                          SCLR='38;5;194'; fi  # light green
  if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$SCLR"; fi
}

# ---- ccusage integration ----
session_txt=""; session_pct=0; session_bar=""
cost_usd=""; cost_per_hour=""; tpm=""; tot_tokens=""

if command -v jq >/dev/null 2>&1; then
  blocks_output=$(npx ccusage@latest blocks --json 2>/dev/null || ccusage blocks --json 2>/dev/null)
  if [ -n "$blocks_output" ]; then
    active_block=$(echo "$blocks_output" | jq -c '.blocks[] | select(.isActive == true)' 2>/dev/null | head -n1)
    if [ -n "$active_block" ]; then
      cost_usd=$(echo "$active_block" | jq -r '.costUSD // empty')
      cost_per_hour=$(echo "$active_block" | jq -r '.burnRate.costPerHour // empty')
      tot_tokens=$(echo "$active_block" | jq -r '.totalTokens // empty')
      tpm=$(echo "$active_block" | jq -r '.burnRate.tokensPerMinute // empty')
      
      # Session time calculation
      reset_time_str=$(echo "$active_block" | jq -r '.usageLimitResetTime // .endTime // empty')
      start_time_str=$(echo "$active_block" | jq -r '.startTime // empty')
      
      if [ -n "$reset_time_str" ] && [ -n "$start_time_str" ]; then
        start_sec=$(to_epoch "$start_time_str"); end_sec=$(to_epoch "$reset_time_str"); now_sec=$(date +%s)
        total=$(( end_sec - start_sec )); (( total<1 )) && total=1
        elapsed=$(( now_sec - start_sec )); (( elapsed<0 ))&&elapsed=0; (( elapsed>total ))&&elapsed=$total
        session_pct=$(( elapsed * 100 / total ))
        remaining=$(( end_sec - now_sec )); (( remaining<0 )) && remaining=0
        rh=$(( remaining / 3600 )); rm=$(( (remaining % 3600) / 60 ))
        end_hm=$(fmt_time_hm "$end_sec")
        session_txt="$(printf '%dh %dm until reset at %s (%d%%)' "$rh" "$rm" "$end_hm" "$session_pct")"
        session_bar=$(progress_bar "$session_pct" 10)
      fi
    fi
  fi
fi

# ---- log extracted data ----
{
  echo "[$TIMESTAMP] Extracted: dir=${current_dir:-}, model=${model_name:-}, version=${model_version:-}, git=${git_branch:-}, context=${context_pct:-}, cost=${cost_usd:-}, cost_ph=${cost_per_hour:-}, tokens=${tot_tokens:-}, tpm=${tpm:-}, session_pct=${session_pct:-}"
} >> "$LOG_FILE" 2>/dev/null

# ---- render statusline ----
# Line 1: Core info (directory, git, model, claude code version, output style)
printf '📁 %s%s%s' "$(dir_color)" "$current_dir" "$(rst)"
printf '  🤖 %s%s%s' "$(model_color)" "$model_name" "$(rst)"
if [ -n "$model_version" ] && [ "$model_version" != "null" ]; then
  printf '  🏷️ %s%s%s' "$(version_color)" "$model_version" "$(rst)"
fi
if [ -n "$cc_version" ] && [ "$cc_version" != "null" ]; then
  printf '  📟 %sv%s%s' "$(cc_version_color)" "$cc_version" "$(rst)"
fi
if [ -n "$output_style" ] && [ "$output_style" != "null" ]; then
  printf '  🎨 %s%s%s' "$(style_color)" "$output_style" "$(rst)"
fi

# Line 2: Context and session time
line2=""
if [ -n "$context_pct" ]; then
  context_bar=$(progress_bar "$context_remaining_pct" 10)
  line2="🧠 $(context_color)Context Remaining: ${context_pct} [${context_bar}]$(rst)"
fi
if [ -n "$session_txt" ]; then
  if [ -n "$line2" ]; then
    line2="$line2  ⌛ $(session_color)${session_txt}$(rst) $(session_color)[${session_bar}]$(rst)"
  else
    line2="⌛ $(session_color)${session_txt}$(rst) $(session_color)[${session_bar}]$(rst)"
  fi
fi
if [ -z "$line2" ] && [ -z "$context_pct" ]; then
  line2="🧠 $(context_color)Context Remaining: TBD$(rst)"
fi

# Line 3: Cost and usage analytics
line3=""
if [ -n "$cost_usd" ] && [[ "$cost_usd" =~ ^[0-9.]+$ ]]; then
  if [ -n "$cost_per_hour" ] && [[ "$cost_per_hour" =~ ^[0-9.]+$ ]]; then
    cost_per_hour_formatted=$(printf '%.2f' "$cost_per_hour")
    line3="💰 $(cost_color)\$$(printf '%.2f' \"$cost_usd\")$(rst) ($(burn_color)\$${cost_per_hour_formatted}/h$(rst))"
  else
    line3="💰 $(cost_color)\$$(printf '%.2f' \"$cost_usd\")$(rst)"
  fi
fi
if [ -n "$tot_tokens" ] && [[ "$tot_tokens" =~ ^[0-9]+$ ]]; then
  if [ -n "$tpm" ] && [[ "$tpm" =~ ^[0-9.]+$ ]]; then
    tpm_formatted=$(printf '%.0f' "$tpm")
    if [ -n "$line3" ]; then
      line3="$line3  📊 $(usage_color)${tot_tokens} tok (${tpm_formatted} tpm)$(rst)"
    else
      line3="📊 $(usage_color)${tot_tokens} tok (${tpm_formatted} tpm)$(rst)"
    fi
  else
    if [ -n "$line3" ]; then
      line3="$line3  📊 $(usage_color)${tot_tokens} tok$(rst)"
    else
      line3="📊 $(usage_color)${tot_tokens} tok$(rst)"
    fi
  fi
fi

# Print lines
if [ -n "$line2" ]; then
  printf '\n%s' "$line2"
fi
if [ -n "$line3" ]; then
  printf '\n%s' "$line3"
fi
printf '\n'
